package jana.util.jar;

import jana.java.JJavaRepository;
import jana.lang.java.JJavaSignature;
import jana.util.JClassFile;
import jana.util.JRelativeFile;

import jana.util.logging.JLogLevel;
import jana.util.logging.JLogger;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarInputStream;
import java.util.jar.JarOutputStream;

public class JJarFile extends JRelativeFile
{
	/**
	 * Generated by Eclipse
	 */
	private static final long serialVersionUID = 7275469678947492157L;

	protected static JLogger logger = JLogger.getLogger(JJavaRepository.DEFAULT_LOGGER);
	private final static boolean LOG_ADDING_FILES = false; 
	
	protected final static int FILE_BUFFER_SIZE = 8192;
	protected final String JAR_FILE_DESIGNATOR = ".jar";
	protected final String CLASS_FILE_DESIGNATOR = ".class";
	
	// Java language noise (why can't I just inherit my super-classes constructors?)
	
	public JJarFile(String fileName, String parentDirName) throws IOException
	{
		super(fileName,parentDirName);
	}
	
	public JJarFile(String fileName, File parent) throws IOException
	{
		super(fileName,parent);
	}
	
	public JJarFile(File file, String parentDirName) throws IOException
	{
		super(file,parentDirName);
	}
	
	public JJarFile(File file, File parent) throws IOException
	{
		super(file,parent);
	}
	
	// the actual constructors
	
	public JJarFile(File aFile) throws IOException
	{
		super(aFile.getCanonicalPath());
	}

	public JJarFile(String pathname) throws IOException
	{
		this(new File(pathname));
	}

	/**
	 * Creates a binary copy of this.file to dstJarFile
	 * 
	 * @param dstJarFile
	 * @param overwrite
	 * @throws IOException
	 */
	public void copyJarFile(File dstJarFile, boolean overwrite) throws IOException
	{
		byte byteBuffer[] = new byte[FILE_BUFFER_SIZE];
		int bytesRead;
		BufferedInputStream srcStream;
		BufferedOutputStream dstStream;
		
		srcStream = null;
		dstStream = null;
		
		JJarFile dst = new JJarFile(dstJarFile); 
		
		if(!this.isFile())
			throw new IOException(this.getCanonicalPath() + " is not a valid source JAR file!");
		if(!this.isValidJarFile())
			throw new IOException(this.getCanonicalPath() + " is not a valid source JAR file!");
		if(!this.canRead())
			throw new IOException("Not enough permissions to read JAR file " + this.getCanonicalPath() + " !");
		if(dst.exists() && !overwrite)
			throw new OverwritingFileException("Trying to Overwrite an existing file! " + dst.getCanonicalPath());
		else
			dst.createNewFile();
		
		if(!dst.canWrite())
			throw new IOException("Not enough permissions to write jar file to " + dst.getCanonicalPath() + " !");
		
		try
		{
		 srcStream = new BufferedInputStream( new FileInputStream(this), FILE_BUFFER_SIZE);
		 dstStream = new BufferedOutputStream( new FileOutputStream(dst), FILE_BUFFER_SIZE);
			  
		 bytesRead = 0;
		 while( (bytesRead = srcStream.read(byteBuffer, 0, FILE_BUFFER_SIZE)) != -1 )
		 {
			dstStream.write(byteBuffer, 0, bytesRead);
		 }
		}
		finally
		{
			srcStream.close();
			dstStream.close();
		}
	}

	/**
	 * Copies this to a destination .jar file, without warning when already existing .jar file is overwritten in the process
	 * 
	 * @param sourceJarFile
	 * @throws IOException
	 */
	public void copyJarFile(File dstJarFile) throws IOException
	{		
		copyJarFile(dstJarFile, false);		
	}
	

	/**
	 * Copy Resource Files
	 * 
	 */
	private final List<String> extractResources(File aDestinationDirectory, boolean overwrite) throws IOException
	{
		byte byteBuffer[] = new byte[FILE_BUFFER_SIZE];
		int bytesRead;
		
		List<String> resourceFiles;
		boolean existed;
		boolean faultyFilename;
		
		JarEntry entry;
		String entryName;
		String entryLowerCaseName;
		
		JRelativeFile dst;
		FileInputStream srcStream;
		FileOutputStream dstStream;
		BufferedOutputStream outStream;
		JarInputStream jinStream;

		srcStream = null;
		dstStream = null; 
		jinStream = null;
		outStream = null;
		
		resourceFiles = new ArrayList<String>();
		
		if(!aDestinationDirectory.isDirectory())
			throw new IOException(aDestinationDirectory.getCanonicalPath() + " is not a valid destination directory!");
		if(!this.isValidJarFile())
			throw new IOException(this.getCanonicalPath() + " is not a valid source JAR file!");
		if(!this.canRead())
			throw new IOException("Not enough permissions to read JAR file " + this.getCanonicalPath() + " !");
		
		if(!aDestinationDirectory.canWrite())
			throw new IOException("Not enough permissions to write to the destination directory " + aDestinationDirectory.getCanonicalPath() + " !");
		
		try
		{
			srcStream = new FileInputStream(this);
			jinStream = new JarInputStream(new BufferedInputStream(srcStream, FILE_BUFFER_SIZE));
					
			entry = jinStream.getNextJarEntry();
			faultyFilename = false;
			
			while(entry != null)
			{
				entryName = entry.getName();
				entryLowerCaseName = entryName.toLowerCase();
				
				if(!(entryLowerCaseName.equals("manifest.mf") || entryLowerCaseName.endsWith(".class")))
				{
					try
					{
						dst = new JRelativeFile(entryName,aDestinationDirectory);
						
						existed = false;
						
						if(dst.exists())
							existed = true;
						
						if((!existed || overwrite))
						{
							try
							{
								dst.createNewFileAndDirectory();
							}
							catch(IOException e)
							{
								logger.warn(e + " " + dst.getCanonicalPath());
								faultyFilename = true;
							}
						}
						
						if(!faultyFilename)
						{
							resourceFiles.add(dst.getRelativePath());
						
							if(dst.isFile() && (!existed || overwrite))
							{
								dstStream = new FileOutputStream(dst);
								outStream = new BufferedOutputStream(dstStream, FILE_BUFFER_SIZE);
						
								bytesRead = 0;
								while( (bytesRead = jinStream.read(byteBuffer, 0, FILE_BUFFER_SIZE)) != -1 )
								{
									outStream.write(byteBuffer, 0, bytesRead);
								}
							}
						}
					}
					finally
					{
						if(outStream != null)
							outStream.close();
						if(dstStream != null)
							dstStream.close();
						dst = null;
					}
				}
					
				
				entry = jinStream.getNextJarEntry();
			}	
		}
		finally
		{
			jinStream.close();
			srcStream.close();
		}	
		
		return resourceFiles;
	}
	
	/**
	 * Extracts the resources of this .jar file to a destination directory
	 * 
	 * @param aDestinationDirectory
	 * @throws IOException
	 */
	public List<String> extractResources(File aDestinationDirectory) throws IOException
	{
		return extractResources(aDestinationDirectory, true);
	}
	
	/**
	 * Enumerates the files in a JAR file and 
	 * adds the signatures of the found class-files to a list
	 * 
	 * @return List<JJavaSignature> a list of signatures of the classes found in the .jar file
	 * @throws IOException
	 */
	public List<JJavaSignature> classesInJarFile() throws IOException
	{
		JarEntry entry;
		List<JJavaSignature> classSignatures;
		
		String entryFileName;
		JClassFile classFile;
		
		JarFile jarFile = new JarFile(this);
		
		classSignatures = new ArrayList<JJavaSignature>(jarFile.size());
		
		for(Enumeration<JarEntry> e = jarFile.entries(); e.hasMoreElements();  )
		{
			entry = e.nextElement();
			if(!entry.isDirectory())
			{
				entryFileName = entry.getName();
				classFile = new JClassFile(entryFileName);
				
				if(classFile.hasClassfileFilenameExtension())
				{
					classSignatures.add(classFile.getSignature());
				}
			}
		}
		
		jarFile.close();
		
		return classSignatures;
	}
		
	/**
	 * Adds all the classes in the list classesToAdd to the .jar file.
	 * The classes are stored relative to the base directory.
	 * 
	 * @param baseDirectory -- the base directory where the classes are stored
	 * @param classesToAdd -- a list of class signatures of the classes that should be added to the .jar file
	 * @throws IOException
	 */
	public void addClasses(File baseDirectory, List<JJavaSignature> classesToAdd) throws IOException
	{
		FileOutputStream dstStream;
		JarOutputStream joutStream;
		
		String classfileName;
		JRelativeFile classfile;
		
		if(classesToAdd.isEmpty())
		{
			logger.warn("There are no classes that could be added to the .jar file!");
			return;
		}
		
		if(!this.hasJARFilenameExtension())
			throw new IOException( this.getName() + " should have the filename extension " + JAR_FILE_DESIGNATOR);
		
		dstStream = new FileOutputStream(this);
		joutStream = new JarOutputStream(new BufferedOutputStream(dstStream, FILE_BUFFER_SIZE));
	
		try
		{					
		  for(JJavaSignature signature : classesToAdd)
		  {
			  classfileName = signature.asClassfileName();
			  classfile = new JRelativeFile(classfileName, baseDirectory);
			  
			  this.addFile(classfile, joutStream);
		  }
		}
		finally
		{
			joutStream.close();
			dstStream.close();
		}
	}
	
	public void addClassesAndResources(File baseDirectory, List<JJavaSignature> classesToAdd, List<String> resourceFilenames) throws IOException
	{
		FileOutputStream dstStream;
		JarOutputStream joutStream;

		JRelativeFile file;
		String classfileName;
		
		if(classesToAdd.isEmpty())
		{
			logger.warn("There are no classes that could be added to the .jar file!");
			return;
		}
		
		if(!this.hasJARFilenameExtension())
			throw new IOException( this.getName() + " should have the filename extension " + JAR_FILE_DESIGNATOR);
		
		dstStream = null;
		joutStream = null;
		
		try
		{
			dstStream = new FileOutputStream(this);
			joutStream = new JarOutputStream(new BufferedOutputStream(dstStream, FILE_BUFFER_SIZE));

			for(String filename : resourceFilenames)
			{
				file = new JRelativeFile(filename, baseDirectory);
				
				this.addFile(file, joutStream);
			}

			for(JJavaSignature signature : classesToAdd)
			{
				classfileName = signature.asClassfileName();
				file = new JRelativeFile(classfileName, baseDirectory);

				this.addFile(file, joutStream);
			}
		}
		finally
		{
			joutStream.close();
			dstStream.close();
		}
	}
	
	private final void addFile(JRelativeFile aFile, JarOutputStream joutStream) throws IOException
	{
		byte byteBuffer[] = new byte[FILE_BUFFER_SIZE];
		int bytesRead;
		BufferedInputStream srcStream;
		JarEntry entry;
		
		srcStream = null;
		
		if( !aFile.exists() )
		{
			logger.error("Can't add the file  " + aFile.getCanonicalPath() + " to the .jar file " + this.getName() + " !");
			throw new IOException("Can't find  " + aFile.getCanonicalPath() + " !");
		}
		else
			if(LOG_ADDING_FILES && JLogLevel.DEBUG.isGreaterOrEqual(logger.getLevel())) // ... give the JITter a chance
				logger.debug("Adding: " + aFile.getRelativePath());
		
		entry = new JarEntry(aFile.getRelativePath());
		
		if(aFile.isDirectory())
		{
			joutStream.putNextEntry(entry);
		}
		
		if(aFile.isFile())
		{
			try
			{
				srcStream = new BufferedInputStream( new FileInputStream(aFile), FILE_BUFFER_SIZE);
				joutStream.putNextEntry(entry);
   
				bytesRead = 0;
				while( (bytesRead = srcStream.read(byteBuffer, 0, FILE_BUFFER_SIZE)) != -1 )
				{
					joutStream.write(byteBuffer, 0, bytesRead);
				}
			}
			finally
			{
				srcStream.close();
			}
		}
	}

	/**
	 * Checks if the file has the .jar filename extension
	 * 
	 * @return the test outcome
	 */
	public boolean hasJARFilenameExtension()
	{
		return this.getPath().toLowerCase().endsWith(JAR_FILE_DESIGNATOR);
	}
	
	/**
	 * A valid jar file ends with .jar, exists, can be read, and has at least one entry
	 * 
	 * @return the result of the test
	 */
	public boolean isValidJarFile()
	{
		if( this.hasJARFilenameExtension() && this.exists() && this.canRead() )
		{
			try
			{
				JarFile jarFile = new JarFile(this);
				return jarFile.size() > 0;
			}
			catch(IOException ioe)
			{
				return false;
			}
		}
		
		return false;
	}
}
